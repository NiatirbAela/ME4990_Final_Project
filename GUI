"""
ME 4990 – Project 2
Minecraft-Themed MNIST GUI (Version 2.1, heavily commented)

This GUI provides:
----------------------------------------
✔ Minecraft-style colors (grass/dirt/stone)
✔ A canvas to display a loaded image
✔ “Load Image” button to open PNG/JPG/BMP
✔ Automatic grayscale conversion and resize to 28x28 for MNIST-like models
✔ Storage of the processed image as a NumPy array for later ML prediction
✔ Model selection radio buttons (3 models)
✔ Prediction button (currently fake)
✔ 10 gray “digit blocks” (0–9) that highlight the predicted digit

This version focuses on clarity + clean comments for understanding.
"""

# ---------------------------
# Standard Library Imports
# ---------------------------
import torch
import torch.nn.functional as F
from torchvision import transforms

import tkinter as tk
from tkinter import ttk, filedialog     # Tkinter file dialog window
from tkinter import messagebox
# ---------------------------
# External Dependencies
# ---------------------------
# Pillow → used for image loading, resizing, grayscale conversion
# NumPy → used to store the 28×28 MNIST-like data array
from PIL import Image, ImageTk
import numpy as np

# Matplotlib → used to create data infographs
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg

try:
    from training_models import Model1, Model2, Model3
except ImportError:
    # optional: ignore if you only need confusion matrices in the GUI for now
    Model1 = Model2 = Model3 = None

# ============================================================
#  COLORS — The Minecraft Theme Palette
# ============================================================

# Grass block top (green)
GRASS_TOP   = "#3c8526"

# Grass block side (darker edge)
GRASS_EDGE  = "#2c5f1b"

# Dirt block background (brown)
DIRT_MAIN   = "#5b3b1f"

# Stone block color (light gray)
STONE_LIGHT = "#808080"

# Stone outline (dark gray)
STONE_DARK  = "#404040"

# Text color (light off-white)
TEXT_LIGHT  = "#f3f3f3"

# Bright green for selected block highlight
ACCENT      = "#62ff6a"


# ============================================================
#  FONTS — Safe, built-in fonts
# ============================================================


# Consolas exists on Windows by default (safe choice).
# Using size variants for headers and body text.
FONT_BASE   = ("Consolas", 11)
FONT_HDR    = ("Consolas", 12, "bold")
FONT_BIG    = ("Consolas", 16, "bold")
FONT_SMALL  = ("Consolas", 10, "bold")


# ============================================================
#  GLOBAL DICTIONARIES/CONFIG — Paths, figures, etc.
# ============================================================

DEVICE = torch.device("cpu")  # GUI runs on CPU

# paths to your trained model weights
MODEL_PATHS = {
    "model1": "saved_models/model1_fc2_best.pth",
    "model2": "saved_models/model2_fc3_best.pth",
    "model3": "saved_models/model3_cnn_best.pth",
}

# paths to your saved confusion matrices
CM_PATHS = {
    "model1": "saved_models/model1_fc2_cm.pt",
    "model2": "saved_models/model2_fc3_cm.pt",
    "model3": "saved_models/model3_cnn_cm.pt",
}

# test accuracies from your final training run (update when you get better ones)
MODEL_ACCURACIES = {
    "model1": 0.87,  # 87% for Model 1
    "model2": 0.59,  # 59% for Model 2
    "model3": 0.89,  # 89% for Model 3
}

# nice model names for the popup title
MODEL_NAMES_PRETTY = {
    "model1": "Model 1 — 2-layer FC",
    "model2": "Model 2 — 3-layer FC",
    "model3": "Model 3 — CNN",
}

# same preprocessing as test_transform in training
gui_transform = transforms.Compose([
    transforms.Grayscale(num_output_channels=1),
    transforms.Resize((28, 28)),
    transforms.ToTensor(),
    transforms.Normalize((0.5,), (0.5,))
])


# ======================================================================
#  MAIN CLASS — Recog_Num
#  This defines the entire GUI window and its functionality.
# ======================================================================

class Recog_Num(ttk.Frame):

    def __init__(self, master):
        """
        Constructor for the GUI class.
        This runs once when the program starts.
        """

        # Call parent constructor
        super().__init__(master, padding=10)

        # Window title
        master.title("Number Recognition")

        # Internal storage:
        self.current_image_path = None        # Path to last loaded image
        self.current_image_array = None       # 28x28 grayscale MNIST-like array
        self.display_photo = None             # Tkinter image reference (must store)

        # Digit block drawing data
        self.block_ids = []       # Canvas object IDs for rectangles
        self.text_ids = []        # Canvas object IDs for the digit text
        self.selected_digit = None  # Which digit is currently highlighted

        # Make GUI stretchable with window resizing
        self.grid(sticky="nsew")
        master.columnconfigure(0, weight=1)
        master.rowconfigure(0, weight=1)

        # Build all GUI parts
        self.build_UI()

        # Draw placeholder so the canvas isn’t empty
        self.show_pic()


    # ======================================================================
    #  BUILD ENTIRE GUI LAYOUT
    # ======================================================================
    def build_UI(self):

        # -----------------------------------------------------
        #  Grass-style title bar at top
        # -----------------------------------------------------
        grass_frame = ttk.Frame(self, style="Grass.TFrame", padding=(10, 6))
        grass_frame.grid(row=0, column=0, columnspan=2, sticky="ew", pady=(0, 8))

        # Dirt strip below grass (Minecraft aesthetic)
        dirt_edge = ttk.Frame(self, style="GrassEdge.TFrame", height=3)
        dirt_edge.grid(row=1, column=0, columnspan=2, sticky="ew")

        # Title text inside the grass bar
        ttk.Label(
            grass_frame,
            text="MNIST Number Recognition",
            style="Title.TLabel",
            anchor="w",
        ).pack(fill="x")


        # -----------------------------------------------------
        #  Left and right side panels
        # -----------------------------------------------------
        self.left_frame = ttk.Frame(self, style="Panel.TFrame", padding=8)
        self.right_frame = ttk.Frame(self, style="Panel.TFrame", padding=8)

        # Layout grid
        self.left_frame.grid(row=2, column=0, sticky="nsew", padx=(0, 6), pady=(8, 0))
        self.right_frame.grid(row=2, column=1, sticky="nsew", padx=(6, 0), pady=(8, 0))

        # Expand left more than right
        self.columnconfigure(0, weight=3)
        self.columnconfigure(1, weight=2)
        self.rowconfigure(2, weight=1)


        # -----------------------------------------------------
        #  LEFT: Canvas where the digit image will be shown
        # -----------------------------------------------------
        self.canvas = tk.Canvas(
            self.left_frame,
            width=220,
            height=220,
            bg=STONE_LIGHT,          # light stone gray
            highlightthickness=3,
            highlightbackground=STONE_DARK,
        )
        self.canvas.pack(expand=True, fill="both")

        # Label under the canvas
        ttk.Label(
            self.left_frame,
            text="Test Image",
            style="Subtle.TLabel",
            anchor="center",
        ).pack(pady=(6, 0))


        # -----------------------------------------------------
        #  RIGHT: Model selection + buttons + digit blocks
        # -----------------------------------------------------

        # Section header
        ttk.Label(
            self.right_frame,
            text="Model Selection",
            style="Header.TLabel",
        ).pack(anchor="w", pady=(0, 4))

        # Radio button state
        self.model_var = tk.StringVar(value="Model 1")

        # Create three radio buttons
        for name in ["Model 1", "Model 2", "Model 3"]:
            ttk.Radiobutton(
                self.right_frame,
                text=name,
                variable=self.model_var,
                value=name,
            ).pack(anchor="w")

        ttk.Separator(self.right_frame).pack(fill="x", pady=8)

        # LOAD IMAGE button — this now works!
        self.load_btn = ttk.Button(
            self.right_frame,
            text="Load Image",
            command=self.load_image,
            style="Accent.TButton",
        )
        self.load_btn.pack(fill="x", pady=2)
        # Predict button — still using fake logic until ML models added
        self.predict_btn = ttk.Button(
            self.right_frame,
            text="Predict",
            command=self.fake_predict,
            style="Accent.TButton",
        )
        self.predict_btn.pack(fill="x", pady=2)

        # Nerd Facts button — opens confusion matrix + per-class accuracy plots
        self.nerd_btn = ttk.Button(
            self.right_frame,
            text="Nerd Facts!",
            command=self.on_nerd_facts,
            style="Accent.TButton",
        )
        self.nerd_btn.pack(fill="x", pady=2)

        ttk.Separator(self.right_frame).pack(fill="x", pady=8)


        # Info label showing model name + accuracy + prediction
        self.info_label = ttk.Label(
            self.right_frame,
            text="Model: N/A\nTraining acc: N/A\nPrediction: N/A",
            style="Info.TLabel",
            justify="left",
        )
        self.info_label.pack(anchor="w", fill="x")

        # Small visual spacer
        ttk.Label(self.right_frame, text="", style="Panel.TLabel").pack(pady=(4, 0))


        # -----------------------------------------------------
        #  DIGIT BLOCKS (0–9)
        # -----------------------------------------------------
        ttk.Label(
            self.right_frame,
            text="Digit Blocks",
            style="Header.TLabel",
        ).pack(anchor="w", pady=(6, 2))

        # Canvas that will hold 10 gray squares
        self.blocks_canvas = tk.Canvas(
            self.right_frame,
            width=260,
            height=48,
            bg=DIRT_MAIN,
            highlightthickness=2,
            highlightbackground=STONE_DARK,
        )
        self.blocks_canvas.pack(fill="x")

        self._get_model_key()
        self._create_number_blocks()


    # ======================================================================
    #  DIGIT BLOCKS (create + highlight)
    # ======================================================================
    def _get_model_key(self):
        """
        Map the GUI radio button text ("Model 1", etc.) to the
        internal keys used in CM_PATHS and MODEL_ACCURACIES.
        """
        gui_name = self.model_var.get()  # "Model 1", "Model 2", or "Model 3"
        mapping = {
            "Model 1": "model1",
            "Model 2": "model2",
            "Model 3": "model3",
        }
        return mapping.get(gui_name)

    def _get_model_key(self):
        """
        Map the GUI radio button text ("Model 1", etc.) to the
        internal keys used in MODEL_PATHS / MODEL_ACCURACIES / CM_PATHS.
        """
        gui_name = self.model_var.get()  # "Model 1", "Model 2", or "Model 3"
        mapping = {
            "Model 1": "model1",
            "Model 2": "model2",
            "Model 3": "model3",
        }
        return mapping.get(gui_name)

    def _get_active_model(self):
        """
        Return the PyTorch model object for the currently selected model.
        Caches the loaded models in self._loaded_models so we don't
        reload from disk every time.
        """
        key = self._get_model_key()
        if key is None:
            messagebox.showerror("Error", "No model selected.")
            return None

        # Create cache dict if it doesn't exist yet
        if not hasattr(self, "_loaded_models"):
            self._loaded_models = {}

        # If we've already loaded this model once, reuse it
        if key in self._loaded_models:
            return self._loaded_models[key]

        # Build the right architecture
        if key == "model1":
            model = Model1()
        elif key == "model2":
            model = Model2()
        elif key == "model3":
            model = Model3()
        else:
            messagebox.showerror("Error", f"Unknown model key: {key}")
            return None

        # Load weights from disk
        path = MODEL_PATHS.get(key)
        if path is None:
            messagebox.showerror("Error", f"No model path found for {key}")
            return None

        try:
            state_dict = torch.load(path, map_location=DEVICE)
        except FileNotFoundError:
            messagebox.showerror("Error", f"Model file not found:\n{path}")
            return None

        model.load_state_dict(state_dict)
        model.to(DEVICE)
        model.eval()

        self._loaded_models[key] = model
        return model


    def _create_number_blocks(self):
        """
        Draw 10 small gray square blocks labeled 0-9.
        """

        block_size = 28         # width/height of each block
        gap = 3                 # small space between blocks
        offset_x = 6            # margin from left
        y0, y1 = 8, 8 + block_size  # top to bottom of square blocks

        for d in range(10):

            # Compute x positions for each block
            x0 = offset_x + d * (block_size + gap)
            x1 = x0 + block_size

            # Rectangle representing the block
            rect = self.blocks_canvas.create_rectangle(
                x0, y0, x1, y1,
                fill="#6e6e6e",        # gray
                outline=STONE_DARK,    # dark border
                width=2,
            )

            # The number text in the center of each block
            txt = self.blocks_canvas.create_text(
                (x0 + x1) // 2,            # horizontal center
                (y0 + y1) // 2,            # vertical center
                text=str(d),
                fill=TEXT_LIGHT,
                font=FONT_SMALL,
            )

            # Store IDs so we can recolor them later
            self.block_ids.append(rect)
            self.text_ids.append(txt)


    def _highlight_block(self, digit):
        """
        Highlight one digit block by making it green.
        All others remain gray.
        """

        # First, reset all blocks back to default gray
        for bid in self.block_ids:
            self.blocks_canvas.itemconfig(
                bid,
                outline=STONE_DARK,
                fill="#6e6e6e",
            )

        # Now highlight the selected one
        if 0 <= digit <= 9:
            self.blocks_canvas.itemconfig(
                self.block_ids[digit],
                outline=ACCENT,
                fill="#47b94f",
            )


    # ======================================================================
    #  IMAGE DISPLAY HELPERS
    # ======================================================================

    def show_pic(self):
        """
        Draw a simple placeholder gray square in the canvas.
        Called at start before any image is loaded.
        """

        self.canvas.delete("all")

        self.canvas.create_rectangle(
            30, 30, 190, 190,
            fill="#9a9a9a",
            outline=STONE_DARK,
            width=3,
        )


    # ======================================================================
    #  REAL "LOAD IMAGE" FUNCTION — This is the important part!
    # ======================================================================
    def load_image(self):
        """
        This is the real image loader.

        What it does:
        1. Opens a file dialog.
        2. User chooses an image (PNG/JPG/BMP).
        3. Loads it using Pillow.
        4. Converts to grayscale.
        5. Resizes to 28x28 for MNIST-like models.
        6. Stores the resulting NumPy array in:
               self.current_image_array
        7. Displays a larger version (160x160) on the GUI canvas.

        This function is ready for real ML models.
        """

        # ------------------ File Dialog ------------------
        filetypes = [
            ("Image files", "*.png *.jpg *.jpeg *.bmp"),
            ("All files", "*.*"),
        ]

        filepath = filedialog.askopenfilename(
            title="Select digit image",
            filetypes=filetypes,
        )

        # If the user cancels the dialog:
        if not filepath:
            return

        self.current_image_path = filepath

        # ------------------ Load Image with Pillow ------------------
        try:
            img = Image.open(filepath)
        except Exception as e:
            print(f"Could not open image: {e}")
            return

        # Convert image to grayscale ("L" mode = 0-255)
        img_gray = img.convert("L")

        # Resize to 28x28 for MNIST-style processing
        img_resized = img_gray.resize((28, 28), Image.Resampling.NEAREST)

        # Convert to NumPy 28x28 array normalized 0..1
        self.current_image_array = np.array(img_resized, dtype=np.float32) / 255.0

        # ------------------ Display on Canvas ------------------
        # Scale up for viewing (the canvas is much bigger)
        display_size = 160
        img_display = img_resized.resize((display_size, display_size),
                                         Image.Resampling.NEAREST)

        # Must keep reference to PhotoImage or Tk will garbage collect it
        self.display_photo = ImageTk.PhotoImage(img_display)

        # Clear old placeholder
        self.canvas.delete("all")

        # Canvas dimensions
        canvas_w = int(self.canvas["width"])
        canvas_h = int(self.canvas["height"])
        x_center = canvas_w // 2
        y_center = canvas_h // 2

        # Draw image centered
        self.canvas.create_image(x_center, y_center, image=self.display_photo)

        # Optional: outline around displayed image
        self.canvas.create_rectangle(
            x_center - display_size // 2,
            y_center - display_size // 2,
            x_center + display_size // 2,
            y_center + display_size // 2,
            outline=STONE_DARK,
            width=3,
        )

    def on_nerd_facts(self):
        """
        Opens a popup window showing:
        - Test accuracy
        - Confusion matrix heatmap
        - Per-class accuracy histogram
        for the currently selected model.
        """
        # Map "Model 1"/"Model 2"/"Model 3" -> "model1"/"model2"/"model3"
        key = self._get_model_key()
        if key is None:
            messagebox.showerror("Error", "No model selected.")
            return

        acc = MODEL_ACCURACIES.get(key)
        cm_path = CM_PATHS.get(key)
        pretty_name = MODEL_NAMES_PRETTY.get(key, key)

        if acc is None or cm_path is None:
            messagebox.showerror("Error", f"No stats available for model key: {key}")
            return

        # Load confusion matrix from saved_models/modelX_cm.pt
        try:
            cm = torch.load(cm_path, map_location="cpu")
        except FileNotFoundError:
            messagebox.showerror("Error", f"Confusion matrix file not found:\n{cm_path}")
            return

        cm_np = cm.numpy()
        num_classes = cm_np.shape[0]

        # Per-class accuracy: diagonal / row sum
        per_class_correct = cm_np.diagonal()
        per_class_total = cm_np.sum(axis=1).clip(min=1)  # avoid divide by zero
        per_class_acc = per_class_correct / per_class_total

        # Create popup window
        win = tk.Toplevel(self)
        win.title(f"Nerd Facts — {pretty_name}")

        # Accuracy label
        acc_label = ttk.Label(
            win,
            text=f"Test Accuracy: {acc*100:.2f}%",
            font=FONT_BIG,
        )
        acc_label.pack(pady=5)

        # Matplotlib figure with 2 subplots
        fig = Figure(figsize=(7, 3), dpi=100)

        # Confusion matrix heatmap
        ax1 = fig.add_subplot(1, 2, 1)
        im = ax1.imshow(cm_np, interpolation="nearest")
        ax1.set_title("Confusion Matrix")
        ax1.set_xlabel("Predicted")
        ax1.set_ylabel("True")
        ax1.set_xticks(range(num_classes))
        ax1.set_yticks(range(num_classes))

        fig.colorbar(im, ax=ax1, fraction=0.046, pad=0.04)

        # Per-class accuracy histogram
        ax2 = fig.add_subplot(1, 2, 2)
        ax2.bar(range(num_classes), per_class_acc)
        ax2.set_title("Per-Class Accuracy")
        ax2.set_xlabel("Digit")
        ax2.set_ylabel("Accuracy")
        ax2.set_xticks(range(num_classes))

        fig.tight_layout()

        canvas = FigureCanvasTkAgg(fig, master=win)
        canvas.draw()
        canvas.get_tk_widget().pack(fill="both", expand=True)

    # ======================================================================
    #  TEMPORARY PREDICT FUNCTION (FAKE OUTPUT)
    # ======================================================================
    
    def fake_predict(self):
        """
        REAL prediction now (name kept the same so the button wiring still works).

        Steps:
        1. Check that an image is loaded (self.current_image_array).
        2. Get the selected model (Model1/2/3) via _get_active_model().
        3. Convert the 28x28 NumPy array to a normalized torch tensor.
        4. Run the model to get logits.
        5. Use argmax to choose the predicted digit 0–9.
        6. Update the info label and highlight the digit block.
        """
        if self.current_image_array is None:
            messagebox.showwarning(
                "No image",
                "Please load an image before predicting."
            )
            return

        # Get the active model based on the radio button
        model = self._get_active_model()
        if model is None:
            return  # error already shown

        # self.current_image_array is 28x28 float32 normalized 0..1
        # Convert to tensor of shape [1, 1, 28, 28]
        img_np = self.current_image_array  # shape (28, 28), values in [0,1]
        img_tensor = torch.from_numpy(img_np).unsqueeze(0).unsqueeze(0).to(DEVICE)

        # Apply the same normalization as in training: Normalize((0.5,), (0.5,))
        # (x - 0.5) / 0.5  -> from [0,1] to [-1,1]
        img_tensor = (img_tensor - 0.5) / 0.5

        # Forward pass through the model
        with torch.no_grad():
            logits = model(img_tensor)          # [1, 10]
            probs = F.softmax(logits, dim=1)    # [1, 10]
            pred_digit = int(torch.argmax(probs, dim=1).item())
            pred_prob = float(probs[0, pred_digit].item())

        # Get GUI name ("Model 1", etc.) and accuracy
        gui_model_name = self.model_var.get()
        model_key = self._get_model_key()
        acc = MODEL_ACCURACIES.get(model_key)
        if acc is not None:
            acc_str = f"{acc*100:.2f}%"
        else:
            acc_str = "N/A"

        # Update info area
        self.info_label.config(
            text=(
                f"Model: {gui_model_name}\n"
                f"Test acc: {acc_str}\n"
                f"Prediction: {pred_digit}  (p={pred_prob:.2f})"
            )
        )

        # Highlight the predicted digit block
        self._highlight_block(pred_digit)

# ======================================================================
#  MAIN SETUP — Tkinter Style Configuration and Window Launch
# ======================================================================

if __name__ == "__main__":

    # Create root window
    root = tk.Tk()
    root.minsize(680, 320)

    # Tkinter style object
    style = ttk.Style()
    try:
        style.theme_use("clam")     # Better layout than default
    except Exception:
        pass

    # Background frames
    root.configure(bg=DIRT_MAIN)
    style.configure("TFrame", background=DIRT_MAIN)
    style.configure("Panel.TFrame", background=DIRT_MAIN)
    style.configure("Grass.TFrame", background=GRASS_TOP)
    style.configure("GrassEdge.TFrame", background=GRASS_EDGE)

    # Label styling
    style.configure("Title.TLabel", background=GRASS_TOP,
                    foreground=TEXT_LIGHT, font=FONT_BIG)
    style.configure("TLabel", background=DIRT_MAIN,
                    foreground=TEXT_LIGHT, font=FONT_BASE)
    style.configure("Panel.TLabel", background=DIRT_MAIN,
                    foreground=TEXT_LIGHT, font=FONT_BASE)
    style.configure("Header.TLabel", background=DIRT_MAIN,
                    foreground=TEXT_LIGHT, font=FONT_HDR)
    style.configure("Subtle.TLabel", background=DIRT_MAIN,
                    foreground="#d0d0d0", font=FONT_SMALL)
    style.configure("Info.TLabel", background="#1f1f1f",
                    foreground=TEXT_LIGHT, font=FONT_BASE, padding=6)

    # Buttons
    style.configure(
        "Accent.TButton",
        background=ACCENT,
        foreground="black",
        font=FONT_BASE,
        padding=4,
        borderwidth=1,
    )
    style.map("Accent.TButton", background=[("active", "#8bff90")])

    # Radio button styling
    style.configure(
        "TRadiobutton",
        background=DIRT_MAIN,
        foreground=TEXT_LIGHT,
        font=FONT_BASE,
    )

    # Make root window stretch nicely
    root.columnconfigure(0, weight=1)
    root.rowconfigure(0, weight=1)

    # Start GUI
    app = Recog_Num(root)
    root.mainloop()
